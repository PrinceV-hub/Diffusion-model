@torch.no_grad()
def sample(model, steps=T):
    model.eval()
    x = torch.randn((1, 3, 32, 32), device=device)  # Start from random noise
    noisy_images = []  # List to hold the noisy images during reverse process

    for t in reversed(range(steps)):
        t_tensor = torch.tensor([t], device=device)
        beta = betas[t]
        alpha = alphas[t]
        alpha_h = alpha_hat[t]

        noise_pred = model(x, t_tensor)
        if t > 0:
            z = torch.randn_like(x) if t > 0 else torch.zeros_like(x)
        else:
            z = 0

        # Reverse process: denoising
        x = (1 / torch.sqrt(alpha)) * (x - (1 - alpha) / torch.sqrt(1 - alpha_h) * noise_pred) + torch.sqrt(beta) * z

        # Capture the noisy image at the first step (when t=999)
        if t == steps - 1:  # Capture the first noisy image (i.e., the one at the last timestep)
            noisy_images.append(x)

    return x, noisy_images


